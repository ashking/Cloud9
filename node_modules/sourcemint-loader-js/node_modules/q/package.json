{
  "name": "q",
  "version": "0.8.2",
  "description": "A library for promises (CommonJS/Promises/A,B,D)",
  "homepage": "http://github.com/kriskowal/q/",
  "author": {
    "name": "Kris Kowal",
    "email": "kris@cixar.com",
    "url": "http://github.com/kriskowal/"
  },
  "contributors": [
    {
      "name": "Kris Kowal",
      "email": "kris@cixar.com",
      "url": "http://github.com/kriskowal/"
    },
    {
      "name": "Irakli Gozalishvili",
      "email": "rfobic@gmail.com",
      "url": "http://jeditoolkit.com"
    }
  ],
  "bugs": {
    "mail": "kris@cixar.com",
    "url": "http://github.com/kriskowal/q/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/kriskowal/q/raw/master/LICENSE"
    }
  ],
  "main": "q.js",
  "repository": {
    "type": "git",
    "url": "http://github.com/kriskowal/q.git"
  },
  "engines": {
    "node": ">=0.2.0",
    "teleport": ">=0.2.0"
  },
  "dependencies": {
    "event-queue": "0.2.0"
  },
  "devDependencies": {
    "test": ">=0.3.0"
  },
  "scripts": {
    "test": "node test/all.js"
  },
  "overlay": {
    "teleport": {
      "dependencies": {
        "event-queue": ">=0.2.0",
        "system": ">=0.0.4"
      }
    }
  },
  "directories": {
    "test": "./test"
  },
  "readme": "[![Build Status](https://secure.travis-ci.org/kriskowal/q.png)](http://travis-ci.org/kriskowal/q)\n\nIf a function cannot return a value or throw an exception without\nblocking, it can return a promise instead.  A promise is an object\nthat represents the return value or the thrown exception that the\nfunction may eventually provide.  A promise can also be used as a\nproxy for a [remote object][Q-Comm] to overcome latency.\n\n[Q-Comm]: https://github.com/kriskowal/q-comm\n\nOn the first pass, promises can mitigate the “[Pyramid of\nDoom][POD]”: the situation where code marches to the right faster\nthan it marches forward.\n\n[POD]: http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/\n\n```javascript\nstep1(function (value1) {\n    step2(value1, function(value2) {\n        step3(value2, function(value3) {\n            step4(value3, function(value4) {\n                // Do something with value4\n            });\n        });\n    });\n});\n```\n\nWith a promise library, you can flatten the pyramid.\n\n```javascript\nQ.call(step1)\n.then(step2)\n.then(step3)\n.then(step4)\n.then(function (value4) {\n    // Do something with value4\n}, function (error) {\n    // Handle any error from step1 through step4\n})\n.end();\n```\n\nWith this approach, you also get implicit error propagation,\njust like ``try``, ``catch``, and ``finally``.  An error in\n``step1`` will flow all the way to ``step5``, where it’s\ncaught and handled.\n\nThe callback approach is called an “inversion of control”.\nA function that accepts a callback instead of a return value\nis saying, “Don’t call me, I’ll call you.”.  Promises\n[un-invert][IOC] the inversion, cleanly separating the\nhandling of input argument from the handling of control\nflow.  This simplifies the use and creation of API’s,\nparticularly variadic parameters (spread and rest\narguments).\n\n[IOC]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\n\n\nGetting Started\n===============\n\nThe Q module can be loaded as:\n\n-   a ``<script>`` tag (creating a ``Q`` global variable)\n-   a NodeJS and CommonJS module available from NPM as the ``q``\n    package\n-   a RequireJS module\n\nPlease join the Q-Continuum [mailing list](https://groups.google.com/forum/#!forum/q-continuum).\n\nQ can exchange promises with jQuery and Dojo and the following libraries\nare based on Q.\n\n-   [q-fs](https://github.com/kriskowal/q-fs)\n    file system\n-   [q-http](https://github.com/kriskowal/q-http)\n    http client and server\n-   [q-comm](https://github.com/kriskowal/q-comm)\n    remote objects\n-   [jaque](https://github.com/kriskowal/jaque)\n    promising HTTP server, JSGI middleware\n\n[Many other projects](http://search.npmjs.org/#/q) in NPM use Q\ninternally or provide Q promises.\n\n\nTutorial\n========\n\nPromises have a ``then`` method, which you can use to get the eventual\nreturn value (fulfillment) or thrown exception (rejection).\n\n```javascript\nfoo()\n.then(function (value) {\n}, function (reason) {\n})\n```\n\nIf ``foo`` returns a promise that gets fulfilled later with a return\nvalue, the first function (the value handler) will be called with the\nvalue.  However, if the ``foo`` function gets rejected later by a\nthrown exception, the second function (the error handler) will be\ncalled with the error.\n\n\n## Propagation\n\nThe ``then`` method returns a promise, which in this example, I’m\nassigning to ``bar``.\n\n```javascript\nvar bar = foo()\n.then(function (value) {\n}, function (reason) {\n})\n```\n\nThe ``bar`` variable becomes a new promise for the return value of\neither handler.  Since a function can only either return a value or\nthrow an exception, only one handler will ever be called and it will\nbe responsible for resolving ``bar``.\n\n-   If you return a value in a handler, ``bar`` will get fulfilled.\n\n-   If you throw an exception in a handler ``bar`` will get rejected.\n\n-   If you return a **promise** in a handler, ``bar`` will “become”\n    that promise.  Being able to become a new promise is useful for\n    managing delays, combining results, or recovering from errors.\n\nIf the ``foo()`` promise gets rejected and you omit the error handler,\nthe **error** will go to ``bar``:\n\n```javascript\nvar bar = foo()\n.then(function (value) {\n})\n```\n\nIf the ``foo()`` promise gets fulfilled and you omit the value\nhandler, the **value** will go to ``bar``:\n\n```javascript\nvar bar = foo()\n.then(null, function (error) {\n})\n```\n\nQ promises provide a ``fail`` shorthand for ``then`` when you are only\ninterested in handling the error:\n\n```javascript\nvar bar = foo()\n.fail(function (error) {\n})\n```\n\nThey also have a ``fin`` function that is like a ``finally`` clause.\nThe final handler gets called, with no arguments, when the promise\nreturned by ``foo()`` either returns a value or throws an error.  The\nvalue returned or error thrown by ``foo()`` passes directly to ``bar``.\n\n```javascript\nvar bar = foo()\n.fin(function () {\n    // close files, database connections, stop servers, conclude tests\n})\n```\n\n-   If the handler returns a value, the value is ignored\n-   If the handler throws an error, the error passes to ``bar``\n-   If the handler returns a promise, ``bar`` gets postponed.  The\n    eventual value or error has the same effect as an immediate return\n    value or thrown error: a value would be ignored, an error would be\n    forwarded.\n\n## Chaining\n\nThere are two ways to chain promises.  You can chain promises either\ninside or outside handlers.  The next two examples are equivalent.\n\n```javascript\nreturn foo()\n.then(function (fooValue) {\n    return bar(fooValue)\n    .then(function (barValue) {\n        // if we get here without an error,\n        // the value retuned here\n        // or the exception thrown here\n        // resolves the promise returned\n        // by the first line\n    })\n})\n```\n\n```javascript\nreturn foo()\n.then(function (fooValue) {\n    return bar(fooValue);\n})\n.then(function (barValue) {\n    // if we get here without an error,\n    // the value retuned here\n    // or the exception thrown here\n    // resolves the promise returned\n    // by the first line\n})\n```\n\nThe only difference is nesting.  It’s useful to nest handlers if you\nneed to capture both ``fooValue`` and ``barValue`` in the last\nhandler.\n\n```javascript\nfunction eventualAdd(a, b) {\n    return a.then(function (a) {\n        return b.then(function (b) {\n            return a + b;\n        });\n    });\n}\n```\n\n\n## Combination\n\nYou can turn an array of promises into a promise for the whole,\nfulfilled array using ``all``.\n\n```javascript\nreturn Q.all([\n    eventualAdd(2, 2),\n    eventualAdd(10, 20)\n])\n```\n\nIf you have a promise for an array, you can use ``spread`` as a\nreplacement for ``then``.  The ``spread`` function “spreads” the\nvalues over the arguments of the value handler.  The error handler\nwill get called at the first sign of failure.  That is, whichever of\nthe recived promises fails first gets handled by the error handler.\n\n```javascript\nfunction eventualAdd(a, b) {\n    return Q.all([a, b])\n    .spread(function (a, b) {\n        return a + b;\n    })\n}\n```\n\nBut ``spread`` calls ``all`` initially, so you can skip it in chains.\n\n```javascript\nreturn foo()\n.then(function (name, location) {\n    return [name, FS.read(location, \"utf-8\")];\n})\n.spread(function (name, text) {\n})\n```\n\n\n## Handling Errors\n\nOne sometimes-unintuive aspect of promises is that if you throw an\nexception in the value handler, it will not be be caught by the error\nhandler.\n\n```javascript\nfoo()\n.then(function (value) {\n    throw new Error(\"Can't bar.\");\n}, function (error) {\n    // We only get here if \"foo\" fails\n})\n```\n\nTo see why this is, consider the parallel between promises and\n``try``/``catch``. We are ``try``-ing to execute ``foo()``: the error\nhandler represents a ``catch`` for ``foo()``, while the value handler\nrepresents code that happens *after* the ``try``/``catch`` block.\nThat code then needs its own ``try``/``catch`` block.\n\nIn terms of promises, this means chaining your error handler:\n\n```javascript\nfoo()\n.then(function (value) {\n    throw new Error(\"Can't bar.\");\n})\n.fail(function (error) {\n    // We get here with either foo's error or bar's error\n})\n```\n\n\n## The End\n\nWhen you get to the end of a chain of promises, you should either\nreturn the last promise or end the chain.  Since handlers catch\nerrors, it’s an unfortunate pattern that the exceptions can go\nunobserved.\n\nSo, either return it,\n\n```javascript\nreturn foo()\n.then(function () {\n    return \"bar\";\n})\n```\n\nOr, end it.\n\n```javascript\nfoo()\n.then(function () {\n    return \"bar\";\n})\n.end()\n```\n\nEnding a promise chain makes sure that, if an error doesn’t get\nhandled before the end, it will get rethrown and reported.\n\nThis is a stopgap. We are exploring ways to make unhandled errors\nvisible without any explicit handling.\n\n\n## The Beginning\n\nEverything above assumes you get a promise from somewhere else.  This\nis the common case.  Every once in a while, you will need to create a\npromise from scratch.\n\nYou can create a promise from a value using ``Q.call``.  This returns a\npromise for 10.\n\n```javascript\nreturn Q.call(function () {\n    return 10;\n});\n```\n\nYou can also use ``call`` to get a promise for an exception.\n\n```javascript\nreturn Q.call(function () {\n    throw new Error(\"Can't do it\");\n})\n```\n\nAs the name implies, ``call`` can call functions, or even promised\nfunctions.  This uses the ``eventualAdd`` function above to add two\nnumbers.  The second argument is the ``this`` object to pass into the\nfunction.\n\n```javascript\nreturn Q.call(eventualAdd, null, 2, 2);\n```\n\nWhen nothing else will do the job, you can use ``defer``, which is\nwhere all promises ultimately come from.\n\n```javascript\nvar deferred = Q.defer();\nFS.readFile(\"foo.txt\", \"utf-8\", function (error, text) {\n    if (error) {\n        deferred.reject(new Error(error));\n    } else {\n        deferred.resolve(text);\n    }\n});\nreturn deferred.promise;\n```\n\nNote that a deferred can be resolved with a value or a promise.  The\n``reject`` function is a shorthand for resolving with a rejected\npromise.\n\n```javascript\nvar rejection = Q.call(function () {\n    throw new Error(\"Can't do it\");\n});\ndeferred.resolve(rejection);\n```\n\nThis is a simplified implementation of ``Q.delay``.\n\n```javascript\nfunction delay(ms) {\n    var deferred = Q.defer();\n    setTimeout(deferred.resolve, ms);\n    return deferred.promise;\n}\n```\n\nThis is a simplified implementation of ``Q.timeout``\n\n```javascript\nfunction timeout(promise, ms) {\n    var deferred = Q.defer();\n    Q.when(promise, deferred.resolve);\n    Q.when(delay(ms), function () {\n        deferred.reject(\"Timed out\");\n    });\n    return deferred.promise;\n}\n```\n\n\n## The Middle\n\nIf you are using a function that may return a promise, but just might\nreturn a value if it doesn’t need to defer, you can use the “static”\nmethods of the Q library.\n\nThe ``when`` function is the static equivalent for ``then``.\n\n```javascript\nreturn Q.when(valueOrPromise, function (value) {\n}, function (error) {\n});\n```\n\nAll of the other methods on a promise have static analogs with the\nsame name.\n\nThe following are equivalent:\n\n```javascript\nreturn Q.all([a, b]);\n```\n\n```javascript\nreturn Q.call(function () {\n    return [a, b];\n})\n.all();\n```\n\nWhen working with promises provided by other libraries, you should\nconvert it to a Q promise.  Not all promise libraries make the same\nguarantees as Q and certainly don’t provide all of the same methods.\nMost libraries only provide a partially functional ``then`` method.\nThis thankfully is all we need to turn them into vibrant Q promises.\n\n```javascript\nreturn Q.when($.ajax(...))\n.then(function () {\n})\n```\n\nIf there is any chance that the promise you receive is not a Q promise\nas provided by your library, you should wrap it using a Q function.\nYou can even use ``Q.call`` as a shorthand.\n\n```javascript\nreturn Q.call($.ajax, $, ...)\n.then(function () {\n})\n```\n\n\n## Over the Wire\n\nA promise can serve as a proxy for another object, even a remote\nobject.  There are methods that allow you to optimistically manipulate\nproperties or call functions.  All of these interactions return\npromises, so they can be chained.\n\n```\ndirect manipulation         using a promise as a proxy\n--------------------------  -------------------------------\nvalue.foo                   promise.get(\"foo\")\nvalue.foo = value           promise.put(\"foo\", value)\ndelete value.foo            promise.del(\"foo\")\nvalue.foo(...args)          promise.post(\"foo\", [args])\nvalue.foo(...args)          promise.invoke(\"foo\", ...args)\nvalue(...args)              promise.apply(null, [args])\nvalue(...args)              promise.call(null, ...args)\nvalue.call(thisp, ...args)  promise.apply(thisp, [args])\nvalue.apply(thisp, [args])  promise.call(thisp, ...args)\n```\n\nIf the promise is a proxy for a remote object, you can shave\nround-trips by using these functions instead of ``then``.  To take\nadvantage of promises for remote objects, check out [Q-Comm][].\n\n[Q-Comm]: https://github.com/kriskowal/q-comm\n\nEven in the case of non-remote objects, these methods can be used as\nshorthand for particularly-simple value handlers. For example, you\ncan replace\n\n```javascript\nreturn Q.call(function () {\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\n})\n.then(function (value) {\n    return value[0].foo;\n})\n```\n\nwith\n\n```javascript\nreturn Q.call(function () {\n    return [{ foo: \"bar\" }, { foo: \"baz\" }];\n})\n.get(0)\n.get(\"foo\")\n```\n\n\n## Adapting Node\n\nThere is a ``node`` method on deferreds that is handy for the NodeJS\ncallback pattern.\n\n```javascript\nvar deferred = Q.defer();\nFS.readFile(\"foo.txt\", \"utf-8\", deferred.node());\nreturn deferred.promise;\n```\n\nAnd there’s a ``Q.ncall`` function for shorter.\n\n```javascript\nreturn Q.ncall(FS.readFile, FS, \"foo.txt\", \"utf-8\");\n```\n\nThere is also a ``Q.node`` function that that creates a reusable\nwrapper.\n\n```javascript\nvar readFile = Q.node(FS.readFile, FS)\nreturn readFile(\"foo.txt\", \"utf-8\");\n```\n\n\nAPI\n---\n\n## ``when(value, fulfilled_opt, rejected_opt)``\n\nArranges for ``fulfilled`` to be called:\n\n-   with the value as its sole argument\n-   in a future turn of the event loop\n-   if and when the value is or becomes a fully resolved\n\nArranges for ``rejected`` to be called:\n\n-   with a value respresenting the reason why the object will\n    never be resolved, typically an ``Error`` object.\n-   in a future turn of the event loop\n-   if the value is a promise and\n    -   if and when the promise is rejected\n\nReturns a promise:\n\n-   that will resolve to the value returned by either of the\n    callbacks, if either of those functions are called, or\n-   that will be rejected if the value is rejected and no\n    ``rejected`` callback is provided, thus forwarding\n    rejections by default.\n\nThe value may be truly __any__ value.  It can be a function.\nIt can be a promise.\n\nEither callback may be falsy, in which case it will not be\ncalled.\n\nGuarantees:\n\n-   ``fulfilled`` will not be called before when returns.\n-   ``rejected`` will not be called before when returns.\n-   ``fulfilled`` will not be called more than once.\n-   ``rejected`` will not be called more than once.\n-   If ``fulfilled`` is called, ``rejected`` will never be called.\n-   If ``rejected`` is called, ``fulfilled`` will never be called.\n-   If a promise is never resolved, neither callback will\n    ever be called.\n\nTHIS IS COOL\n\n-   You can set up an entire chain of causes and effects in the\n    duration of a single event and be guaranteed that any invariants\n    in your lexical scope will not...vary.\n-   You can both receive a promise from a sketchy API and return a\n    promise to some other sketchy API and, as long as you trust this\n    module, all of these guarantees are still provided.\n-   You can use when to compose promises in a variety of ways, for\n    example:\n\nINTERSECTION\n\n    function and(a, b) {\n        return Q.when(a, function (a) {\n            return Q.when(b, function (b) {\n                // ...\n            });\n        })\n    }\n\n\n## ``defer()``\n\nReturns a \"deferred\" object with a:\n\n-   ``promise`` property\n-   ``resolve(value)`` function\n-   ``reject(reason)`` function\n-   ``node()`` function\n\nThe promise is suitable for passing as a value to the\n``when`` function, among others.\n\nCalling resolve with a promise notifies all observers that\nthey must now wait for that promise to resolve.\n\nCalling resolve with a rejected promise notifies all\nobservers that the promise will never be fully resolved with\nthe rejection reason.  This forwards through the the chain\nof ``when`` calls and their returned promises until it\nreaches a ``when`` call that has a ``rejected`` callback.\n\nCalling resolve with a fully resolved value notifies all\nobservers that they may proceed with that value in a future\nturn.  This forwards through the ``fulfilled`` chain of any\npending ``when`` calls.\n\nCalling ``reject`` with a reason is equivalent to resolving\nwith a rejection.\n\nIn all cases where the resolution of a promise is set,\n(promise, rejection, value) the resolution is permanent and\ncannot be reset.  All future observers of the resolution of\nthe promise will be notified of the resolved value, so it is\nsafe to call ``when`` on a promise regardless of whether it\nhas been or will be resolved.\n\nCalling ``node()`` returns a callback suitable for passing\nto a Node function.\n\n\nTHIS IS COOL\n\nThe Deferred separates the promise part from the resolver\npart. So:\n\n-   You can give the promise to any number of consumers and\n    all of them will observe the resolution independently.\n    Because the capability of observing a promise is\n    separated from the capability of resolving the promise,\n    none of the recipients of the promise have the ability\n    to \"trick\" other recipients with misinformation.\n\n-   You can give the resolver to any number of producers and\n    whoever resolves the promise first wins.  Furthermore,\n    none of the producers can observe that they lost unless\n    you give them the promise part too.\n\n\nUNION\n\n    function or(a, b) {\n        var union = Q.defer();\n        Q.when(a, union.resolve);\n        Q.when(b, union.resolve);\n        return union.promise;\n    }\n\n\n## ``resolve(value)``\n\nIf value is a promise, returns the promise.\n\nIf value is not a promise, returns a promise that has\nalready been fulfilled with the given value.\n\n\n## ``reject(reason)``\n\nReturns a promise that has already been rejected with the\ngiven reason.\n\nThis is useful for conditionally forwarding a rejection\nthrough an errback.\n\n    Q.when(API.getPromise(), function (value) {\n        return doSomething(value);\n    }, function (reason) {\n        if (API.stillPossible()) {\n            return API.tryAgain();\n        } else {\n            return Q.reject(reason);\n        }\n    })\n\nUnconditionally forwarding a rejection is equivalent to\nomitting an errback on a when call.\n\n    Q.when(API.getPromise(), function (value) {\n        return doSomething(value);\n    }, function (reason) {\n        return Q.reject(reason);\n    })\n\nSimplifies to:\n\n    Q.when(API.getPromise(), function (value) {\n        return doSomething(value);\n    })\n\n\n## ``isPromise(value)``\n\nReturns whether the given value is a promise.\n\n\n## ``isResolved(value)``\n\nReturns whether the given value is fulfilled or rejected.\nNon-promise values are equivalent to fulfilled promises.\n\n\n## ``isFulfilled(value)``\n\nReturns whether the given value is fulfilled.  Non-promise\nvalues are equivalent to fulfilled promises.\n\n\n## ``isRejected(value)``\n\nReturns whether the given value is a rejected promise.\n\n\n## ``end(promise)``\n\nAccepts a promise that is intended to be the last promise in\na chain of promises.  If an error propagates to the end of\nthe promise chain, it will be thrown as an exception and\nhandled by either NodeJS or the browser as an uncaught\nexception.\n\n\n## ``enqueue(callback Function)``\n\nCalls ``callback`` in a future turn.\n\n\nADVANCED API\n------------\n\nThe ``ref`` promise constructor establishes the basic API\nfor performing operations on objects: \"get\", \"put\", \"del\",\n\"post\", \"apply\", and \"keys\".  This set of \"operators\" can be\nextended by creating promises that respond to messages with\nother operator names, and by sending corresponding messages\nto those promises.\n\n\n## ``makePromise(handlers, fallback_opt, valueOf_opt)``\n\nCreates a stand-alone promise that responds to messages.\nThese messages have an operator like \"when\", \"get\", \"put\",\nand \"post\", corresponding to each of the above functions for\nsending messages to promises.\n\nThe ``handlers`` are an object with function properties\ncorresponding to operators.  When the made promise receives\na message and a corresponding operator exists in the\n``handlers``, the function gets called with the variadic\narguments sent to the promise.  If no ``handlers`` object\nexists, the ``fallback`` function is called with the operator,\nand the subsequent variadic arguments instead.  These\nfunctions return a promise for the eventual resolution of\nthe promise returned by the message-sender.  The default\nfallback returns a rejection.\n\nThe ``valueOf`` function, if provided, overrides the\n``valueOf`` function of the returned promise.  This is useful\nfor providing information about the promise in the same turn\nof the event loop.  For example, resolved promises return\ntheir resolution value and rejections return an object that\nis recognized by ``isRejected``.\n\n\n## ``send(value, operator, ...args)``\n\nSends an arbitrary message to a promise.\n\nCare should be taken not to introduce control-flow hazards\nand security holes when forwarding messages to promises.\nThe functions above, particularly ``when``, are carefully\ncrafted to prevent a poorly crafted or malicious promise\nfrom breaking the invariants like not applying callbacks\nmultiple times or in the same turn of the event loop.\n\n\n## ``get(object, name)``\n\nReturns a promise for the named property of an object,\nalbeit a promise for an object.\n\n\n## ``put(object, name, value)``\n\nReturns a promise to set the named property of an object,\nalbeit a promise, to the given value.\n\n\n## ``del(object, name)``\n\nReturns a promise to delete the named property of an object,\nalbeit a promise.\n\n\n## ``post(object, name, arguments)``\n\nReturns a promise to call the named function property of an\neventually fulfilled object with the given array of\narguments.  The object itself is ``this`` in the function.\n\n\n## ``invoke(object, name, ...arguments)``\n\nReturns a promise to call the named function property of an\neventually fulfilled object with the given variadic\narguments.  The object itself is ``this`` in the function.\n\n\n## ``keys(object)``\n\nReturns a promise for an array of the property names of the\neventually fulfilled object.\n\n\n## ``apply(function, this, arguments)``\n\nReturns a promise for the result of calling an eventually\nfulfilled function, with the given values for the ``this``\nand ``arguments`` array in that function.\n\n\n## ``call(function, this, ...arguments)``\n\nReturns a promise for the result of eventually calling the\nfulfilled function, with the given context and variadic\narguments.\n\n\n## ``all([...promises])``\n\nReturns a promise for an array of the fulfillment of each\nrespective promise, or rejects when the first promise is\nrejected.\n\n\n## ``fail(promise, callback())``\n\nAccepts a promise and captures rejection with the callback,\ngiving the callback an opportunity to recover from the\nfailure.  If the promise gets rejected, the return value of\nthe callback resolves the returned promise.  Otherwise, the\nfulfillment gets forwarded.\n\n\n## ``fin(promise, callback())``\n\nLike a ``finally`` clause, allows you to observe either the\nfulfillment or rejection of a callback, but to do so without\nmodifying the final value.  This is useful for collecting\nresources regardless of whether a job succeeded, like\nclosing a database connection, shutting a server down, or\ndeleting an unneeded key from an object. The callback \nreceives no arguments.\n\n\n## ``end(promise)``\n\nAccepts a promise and returns ``undefined``, to terminate a\nchain of promises at the end of a program.  If the promise\nis rejected, throws it as an exception in a future turn of\nthe event loop.\n\nSince exceptions thrown in ``when`` callbacks are consumed\nand transformed into rejections, exceptions are easy to\naccidentally silently ignore.  It is furthermore non-trivial\nto get those exceptions reported since the obvious way to do\nthis is to use ``when`` to register a rejection callback,\nwhere ``throw`` would just get consumed again.  ``end``\narranges for the error to be thrown in a future turn of the\nevent loop, so it won't be caught; it will cause the\nexception to emit a browser's ``onerror`` event or NodeJS's\n``process`` ``\"uncaughtException\"``.\n\n\n## ``async(generatorFunction)``\n\nThis is an experimental tool for converting a generator\nfunction into a deferred function.  This has the potential\nof reducing nested callbacks in engines that support\n``yield``.  See ``examples/async-generators/README.md`` for\nfurther information.\n\n\n## ``node(nodeFunction)``\n\nWraps a Node function so that it returns a promise instead\nof accepting a callback.\n\n```javascript\nvar readFile = FS.node(FS.readFile);\nreadFile(\"foo.txt\")\n.then(function (text) {\n});\n```\n\nThe ``this`` of the call gets forwarded.\n\n```javascript\nvar readFile = FS.node(FS.readFile);\nFS.readFile.call(FS, \"foo.txt\")\n.then(function (text) {\n});\n```\n\nThe ``node`` call can also be used to bind and partially\napply.\n\n```javascript\nvar readFoo = FS.node(FS.readFile, FS, \"foo.txt\");\nreadFoo()\n.then(function (text) {\n});\n```\n\n\n## ``ncall(nodeFunction, thisp, ...args)``\n\nCalls a Node function, returning a promise so you don’t have\nto pass a callback.\n\n```javascript\nQ.ncall(FS.readFile, FS, \"foo.txt\")\n.then(function (text) {\n});\n```\n\n\nChaining\n--------\n\nPromises created by the Q API support chaining for some\nfunctions.  The ``this`` promise becomes the first argument\nof the corresponding Q API function.  For example, the\nfollowing are equivalent:\n\n-   ``when(promise, fulfilled)`` and\n    ``promise.then(fulfilled)``.\n-   ``end(promise)`` and ``promise.end()``.\n\nThe following functions are supported for chaining:\n\n-   ``.when`` (``.then``)\n-   ``.get``\n-   ``.put``\n-   ``.del``\n-   ``.post``\n-   ``.invoke``\n-   ``.apply``\n-   ``.call``\n-   ``.keys``\n-   ``.all``\n-   ``.fin``\n-   ``.end``\n\n\nCopyright 2009-2011 Kristopher Michael Kowal\nMIT License (enclosed)\n\n",
  "readmeFilename": "README.md",
  "_id": "q@0.8.2",
  "dist": {
    "shasum": "94e39f123beb9366781e7ad197b56e0aedac8e2b"
  },
  "_from": "q@0.8.2",
  "_resolved": "https://registry.npmjs.org/q/-/q-0.8.2.tgz"
}
