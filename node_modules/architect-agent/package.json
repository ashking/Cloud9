{
  "author": {
    "name": "Tim Caswell",
    "email": "tim@c9.io"
  },
  "name": "architect-agent",
  "description": "This is the rpc agent for the architect plugin framework",
  "version": "0.2.2",
  "repository": {
    "type": "git",
    "url": "git://github.com/c9/architect-agent.git"
  },
  "main": "architect-agent.js",
  "engines": {
    "node": "~0.6.0"
  },
  "devDependencies": {
    "architect-socket-transport": "~0.2.0",
    "architect-fake-transports": "~0.2.0"
  },
  "readme": "This module is the actual serialization format and protocol for the remoteagent system.\n\nIt is transport agnostic so that it can work on any duplex socket.  A modified\nversion of msgpack is used as the serialization format when using the binary\nsocket transport (`undefined` and `Buffer` types are added).  Other transports\nsuch as socket.io in the browser can be used.\n\nEncoded on top of the serialzation format is functions and cycles.  This\nalmost any basic value can be encoded and sent across the socket.\n\nSince functions can be serialized, rpc using callbacks is natural.  Simply\npass your callback as an argument and the other side will get a proxy function\nwhen it's deserialized.  When they call that proxy function, a message will be\nsent back and your callback will get called with the deserialized arguments\n(which can include yet another callback).  Since the callbacks are executed on\ntheir native side, closure variables and all other state is preserved.\nCallbacks functions may only be called once.  The internal reference is\ndeleted after the first call.  For functions that are called multiple times,\nuse the named functions map passed into the Agent.\n\n\n## Message Encoding\n\nOn top of serializing primitive values and basic data structures, remoteagent-\nprotocol can encode proxy functions and cycles in an object.  This is encoded\nusing objects with the `$` magic key.  Any existing keys that start with `$`\nwill be escaped by prefixing an extra $.\n\n### Function Encoding\n\nFunctions are encoded with the `$` key.  The value of this object is the\nunique function index in the local function repository.  Function keys\nintegers. An example encoded function can look like `{$: 3}` where\n`callbacks[3]` in the server is the real function.\n\n### Cycle Encoding\n\nSometimes objects have cycles in them.  It would be nice if these could be\nencoded, serialized, and send to the other side intact without blowing up the\nrpc system.  Cycles are encoded with the `$` key.  The value is the path to\nthe actual value as an array of strings.  In this way it works like a file-\nsystem symlink.  Currently the path is absolute starting at the root of the\nmessage.  For example.  Given the following cyclic object:\n\n```js\nvar entry = {\n  name: \"Bob\",\n  boss: { name: \"Steve\" }\n};\nentry.self = entry;\nentry.manager = entry.boss;\n```\n\nThe following encoded object is generated by the internal `freeze` function in\n`protocol.serializer()`.\n\n```js\n{\n  name: 'Bob',\n  boss: { name: 'Steve' },\n  self: { $: [] },\n  manager: { $: [ 'boss' ] }\n}\n```\n\nSee that the path `[]` point to the object itself, and `['boss']` points to\nthe boss property in the root.\n\n## Agents\n\nThe main public interface is the Agent class.  There is typically one of these per network node (process) in a remoteagent mesh.  The agent holds the named functions that this node serves to the other nodes.\n\n```js\nvar Agent = require('architect-agent').Agent;\n\nvar agent = new Agent({\n\tadd: function (a, b, callback) {\n\t\tcallback(a + b);\n\t}\n});\n```\n\nIn this example, we created a new agent, gave it the ID `\"main\"` and declared that it provides an add function.\n\n## Transports\n\nTransports handle internally the serialization of static objects.  This can be\nJSON or msgpack or something else.\n\nTransports must have a `.send()` property for sending messages to the other\nside and emit `\"message\"` events (or call their `onMessage` property) whenever a message arrives from the other\nside. The message is an object not a json string or msgpack buffer.  The\ntransport is not responsible for encoding functions and cycles, that is done\nat a higher level.\n\nWhen using the built-in socket-transport, messages are framed in the stream\nusing a 4 byte length header (UInt32BE) before every message.  This way the\nreceiving end knows how much buffer to allocate and can efficiently scan and\ndeframe the incoming message stream.  This also means that the msgpack parser\ncan assume it has the entire message in memory once the message emit from the\ndeframer.\n\nHere is an example networkserver that accepts remoteagent connections over a\ntcp port.  We are assuming the `agent` variable declared in the sample above.\n\n```js\nvar net = require('net');\nvar socketTransport = require('architect-socket-transport');\n\nnet.createServer(function (socket) {\n\tagent.attach(socketTransport(socket), function (client) {\n\t\t// Do something with client if it has functions to serve\n\t});\n}).listen(1337);\n```\n\nThen to connect to this, from the client connect to this server.\n\n```js\nvar net = require('net');\nvar socketTransport = require('architect-socket-transport');\n\nvar Agent = require('architect-agent').Agent;\n\nvar agent = new Agent();\n\nvar client = net.connect(1337, function () {\n\tagent.attach(socketTransport(client), function (server) {\n\t\t// Use server's exported functions\n\t\tserver.add(1, 2, function (result) {\n\t\t\t// result should be 3!\n\t\t});\n\t});\n});\n```\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/c9/architect-agent/issues"
  },
  "_id": "architect-agent@0.2.2",
  "_from": "architect-agent@0.2.2"
}
